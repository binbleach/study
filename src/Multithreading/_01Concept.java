package Multithreading;

/*
* 进程就是一个程序 软件像是jvm
* 线程是多个执行场景/执行单元/或者模块，比如java程序执行main方法和垃圾回收器
*
* 进程内存独立不共享，线程之间看情况
*
* java虚拟机中多线程堆内存和方法区共享，多线程栈内存不共享，一个线程一个栈(方法区和堆共享),几个栈就有几个线程
*
*启动10个线程就会有十个栈，之间互不干扰各自进行各自的这就是多线程并发，可以提高处理速度效率
* 从此以后main方法介绍程序不一定结束，只是主线程结束
*
* 线程和进程：公司和公司员工，火车站和火车站售票窗口
*
* 单核cpu不能实现真正得多线程并发，但是可以给人营造多线程的感觉
*
* 两种实现线程的方式：
* 1、extends继承Thread,重写run方法.因为一个类只能继承一个所以有局限性
* 2、implements实现runnable接口就不会，所以相对来说好一点
*
* 线程的生命周期：
* 新建状态（new的时候），就绪状态(start（）执行的时候，可运行状态，具有抢夺cpu时间片的权利)，
* 运行状态(run()方法的执行表示进入运行状态，时间片用完就回到就绪状态)，死亡状态（run结束标志进入死亡状态）
*当一个线程遇到阻塞时间如用户键盘输入和sleep会进入阻塞状态，线程会放弃占有的时间片阻塞接触会变到就绪状态继续抢夺cpu时间片
*
* 关于线程的调度方法：
* 1、抢占式调度模型
* java用的就是这种
*
* 实例方法：
* void setPriority(int newPriority)设置线程的优先级1级最低，默认是5，最高是10优先级高的抢到的时间片多一些
*int getPriority() 获取线程优先级
* 静态方法：Thread.yield();让位法，不是阻塞，是回到就绪继续抢不过会一定降低成功率
*
* 2、均分式调度模型
*
*
* */
public class _01Concept {
}
