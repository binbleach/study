线程安全问题三种条件
1、多线程线程并发，2、有数据共享，3、有修改数据的操作
解决方法：不让线程并发，同步，排队

synchronized与其说是锁与其说是钥匙更好理解，一个对象一个锁，看到synchronized就去锁池里找锁，找到就能进
运行状态->找锁并放弃强到的时间片；找到->就绪状态

局部变量栈中 ，永远不会发送线程安全问题因为不共享 #方法里的变量
实例变量堆中（成员变量）                        #类里的变量
静态变量方法区中（成员变量）                    #类里的变量

StringBuffer线程安全
StringBuilder 线程不安全 局部变量用这个，不用考虑线程安全问题，效率高

synchronized三种锁法：
1、代码块上，灵活（对象锁）
synchronized(共享对象){}

2、实例方法上，共享对象一定是this,不太灵活且可能会扩大范围，不过代码少（对象锁）
synchronized void 实例方法名(){}

3、静态方法上，表示类锁，保证静态变量的安全，类锁只有一把就算创建了一百个类也只有一把类锁

不得已的情况下才用锁，1、用局部变量代替成员变量。2、多创建几个对象避免对象共享。
3、不行就锁吧，效率低，用户吞吐量低，用户体验差。

守护线程就是后台线程其他是用户线程
守护线程是一个死循环，所有的用户线程结束守护线程也就结束

wait() 方法和notify()方法是通过Object调的，每个Object对象都有
